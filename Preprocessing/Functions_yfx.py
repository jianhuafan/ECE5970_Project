import numpy as npfrom time import gmtime, strftimefrom sklearn.preprocessing import Imputerfrom sklearn.decomposition import PCAfrom sklearn import preprocessingfrom sklearn.feature_selection import VarianceThresholdimport matplotlib.pyplot as pltdef v_t(data, thres):    sel = VarianceThreshold(thres)    output = sel.fit_transform(data)    return output### input & output are both 2D listdef delete_sparse(input,threshold):    ## threshold is a number in range (0,100)    nRows = len(input)    nColumns = len(input[0])    stat = []     ## store percetage of each feature    counter  = 0  ## temporary counter    n = 0         ## number of features above threshold    thres_n = []  ## list to store number of features above a threshold    for j in range(nColumns):        counter = 0        for i in range(nRows):            if input[i][j] != '':                counter += 1        stat.append(counter)    output = []    for i in range(nRows):        output.append([])    for j in range(nColumns):        if stat[j]/nRows > threshold/100:            for i in range(nRows):                output[i].append(input[i][j])    # for k in range(100):    #     thres_n.append(0)    #     for j in range(nColumns):    #         if stat[j]/nRows > k/100:    #             thres_n[k] += 1    #     print("thresold is:",k/100,"there are:",thres_n[k],"features")    return output## input is 2D list, output is 1D listdef select_sparse(input,threshold):    ## threshold is a number in range (0,100)    nRows = len(input)    nColumns = len(input[0])    stat = []     ## store percetage of each feature    counter  = 0  ## temporary counter    n = 0         ## number of features above threshold    for j in range(nColumns):        counter = 0        for i in range(nRows):            if input[i][j] != '':                counter += 1        stat.append(counter)    output = []    for j in range(nColumns):        if stat[j]/nRows > threshold/100:            output.append(1)        else:            output.append(0)    return statdef delete_colunms(input,columns):    output = []    for i in range(len(input)):        output.append([])    k = 0    for j in range(len(input[0])):        if k < len(columns):            if j == columns[k] :                # print("k=",k,"j=",j)                k += 1                continue        for i in range(len(input)):            output[i].append(input[i][j])    return outputdef locf(reader,label):    nRows = len(reader)    nColumns = len(reader[1])    data_float = []    for i in range(nRows):        data_float.append([])    print("loop1 starts:", strftime("%Y-%m-%d %H:%M:%S", gmtime()))    for j in range(nColumns):        for i in range(nRows):            data_float[i].append(float(reader[i][j]))    print("loop1 ends", strftime("%Y-%m-%d %H:%M:%S", gmtime()))    # build an empty array to store previous date and it row number    DataAux = []    for i in range(nRows):        DataAux.append([])    for i in range(nRows):  # write PID & Date to DataAux        DataAux[i].append(data_float[i][0])        DataAux[i].append(data_float[i][1])    Temp = []    n = 0    for i in range(nRows):        n += 1  # n counts the number of samples of a same PID        Temp.append(DataAux[i][1])  # temporarily store date        if i != nRows - 1:  # insure the matrix won't go out of index            if DataAux[i][0] != DataAux[i + 1][0]:                Temp.sort()  # find the order for each sample                for j in range(n):                    for k in range(n):                        if Temp[j] == DataAux[i - n + 1 + k][1]:                            DataAux[i - n + 1 + k].append(j)                            break                for j in range(n):                    if len(DataAux[i - n + 1 + j]) != 3:                        print(i)                        # DataAux[i-n+1+j].append()                for j in range(n):  # find the previous                    if DataAux[i - n + 1 + j][2] == 0:                        DataAux[i - n + 1 + j].append(i - n + 1 + j)                    else:                        for k in range(n):                            if DataAux[i - n + 1 + j][2] == (DataAux[i - n + 1 + k][2] + 1):                                # print(i-n+1+j,DataAux[i-n+1+j][2])                                DataAux[i - n + 1 + j].append(i - n + 1 + k)                                break                n = 0                Temp = []        else:  # suppose they are the same            Temp.sort()            for j in range(n):                for k in range(n):                    if Temp[j] == DataAux[i - n + 1 + k][1]:                        DataAux[i - n + 1 + k].append(j)                        break            for j in range(n):                if len(DataAux[i - n + 1 + j]) != 3:                    DataAux[i - n + 1 + j].append()            for j in range(n):  # find the previous                if DataAux[i - n + 1 + j][2] == 0:                    DataAux[i - n + 1 + j].append(i - n + 1 + j)                else:                    for k in range(n):                        if DataAux[i - n + 1 + j][2] == (DataAux[i - n + 1 + k][2] + 1):                            # print(i-n+1+j,DataAux[i-n+1+j][2])                            DataAux[i - n + 1 + j].append(i - n + 1 + k)                            continue            n = 0            Temp = []    # print("auxiliary list built")    n1 = 0    t = 0    for i in range(nRows):        for j in range(nColumns):            if data_float[i][j] == label:                n1 += 1                if data_float[DataAux[i][3]][j] != label:                    data_float[i][j] = data_float[DataAux[i][3]][j]                else:                    t = i                    for k in range(0, 20):                        prev = DataAux[t][3]                        t = prev                        if data_float[t][j] != label:                            data_float[i][j] = data_float[t][j]                            break    print(nColumns)    n2 = 0    for i in range(nRows):        for j in range(nColumns):            if data_float[i][j] == label:                n2 += 1    print("before LOCF, there are:", n1, "miss data.")    print("afterwards, there are:", n2, "missing data,imputation ratio is:", (n1 - n2) / n1)    # median imputation    imp = Imputer(missing_values=label, strategy='median', axis=0)    imp.fit([data_float[0], data_float[1], data_float[2]]);    data_float = imp.transform(data_float);    output = []    for i in range(len(data_float)):        output.append([])        for j in range(len(data_float[0])):            output[i].append(data_float[i][j])    return outputdef locf_pre(data):    del data[0]    data = to_float(data)    # put patients with same PID together    data.sort(key=lambda tup: tup[0])    delete = []    # delete patients with same PID & same exam date    for i in range(len(data)-20):        for j in range(1,20):  # suppose there are at most 20 row for a same PID            if data[i][0] != data[i+j][0]:                break            else:                if data[i][1] == data[i+j][1]:                    delete.append(i)    for i in range(len(delete)):        del data[delete[i]]    return datadef pca(reader,threshold):    nRows = len(reader)    nColumns = len(reader[1])    data_float = []    output = []    # build a list without without PID & Exam-date -->   data_float    for i in range(nRows):        data_float.append([])    for i in range(nRows):        output.append([])    for j in range(2, nColumns):        for i in range(nRows):            data_float[i].append(float(reader[i][j]))    data_float = np.asarray(data_float)    # scale the data before pca    data_float = preprocessing.scale(data_float)    nComponents = len(data_float[0])    pca = PCA(n_components=nComponents)    res = pca.fit_transform(data_float)    n = 0    per = 0    y_axis = []    x_axis = []    print(pca.explained_variance_ratio_)    for n in range(len(pca.explained_variance_ratio_)):        per += pca.explained_variance_ratio_[n]        if per > threshold:            break    n += 1    print(n)    k = 0    per = 0    for k in range(len(pca.explained_variance_ratio_)):        per += pca.explained_variance_ratio_[k]        y_axis.append(per)        x_axis.append(k + 1)    import matplotlib.pyplot as plt    plt.plot(x_axis, y_axis, 'ro')    plt.axis([0, k, 0, 1])    plt.show()    for i in range(len(data_float)):        output.append([])        output[i].append(reader[i][0])        output[i].append(reader[i][1])    for j in range(n+2):        for i in range(len(data_float)):            output[i].append(res[i,j])    return outputdef sum_col(data,c):    res = 0    for i in range(len(data)):        res += data[i][c]    return resdef to_float(data):        for i in range(len(data)):            for j in range(len(data[0])):                data[i][j] = float(data[i][j])        return datadef sca(data):    nRows = len(data)    nColumns = len(data[1])    data_float = []    output = []    # build a nparray without PID & Exam-date & Classcification data -->   data_float    for i in range(nRows):        data_float.append([])    for i in range(nRows):        output.append([])    for j in range(2, nColumns):        for i in range(nRows):            data_float[i].append(float(data[i][j]))    data_float = np.asarray(data_float)    # scale the data before pca    res = preprocessing.scale(data_float)    for i in range(len(data_float)):        output.append([])        output[i].append(data[i][0])        output[i].append(data[i][1])        # output[i].append(data[i][2])        # output[i].append(data[i][3])        # output[i].append(data[i][4])    for j in range(len(data[0])-2):        for i in range(len(data_float)):            output[i].append(res[i, j])    return outputdef swap_col(m,n,data):    row = len(data)    temp = []    for i in range(row):        temp.append(data[i][m])        data[i][m] = data[i][n]    for i in range(row):        data[i][m] = temp[i]    return data